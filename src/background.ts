import browser from 'webextension-polyfill';

import type { Profile, RequestHeader } from '#entities/request-profile/types';

import { BrowserStorageKey, ServiceWorkerEvent } from './shared/constants';
import { browserAction } from './shared/utils/browserAPI';
import { logger, LogLevel } from './shared/utils/logger';
import { setBrowserHeaders } from './shared/utils/setBrowserHeaders';
import { setIconBadge } from './shared/utils/setIconBadge';
import { enableExtensionReload } from './utils/extension-reload';

logger.configure({
  minLevel: process.env.NODE_ENV === 'development' ? LogLevel.DEBUG : LogLevel.INFO,
  showTimestamp: true,
  enabled: true,
});

// –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç—ã background script
logger.info('üéØ Background script loaded successfully!');
// –î—É–±–ª–∏—Ä—É–µ–º –≤ logger.debug –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏
logger.debug('üéØ Background script loaded successfully! (debug)');
logger.info('üîç About to check storage contents...');

// –ü—Ä–æ–≤–µ—Ä—è–µ–º storage —Å—Ä–∞–∑—É –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ background script
(async () => {
  try {
    const result = await browser.storage.local.get([
      BrowserStorageKey.Profiles,
      BrowserStorageKey.SelectedProfile,
      BrowserStorageKey.IsPaused,
    ]);

    logger.group('üì¶ Storage contents on background script load:', true);
    logger.info('  - Profiles:', result[BrowserStorageKey.Profiles] ? 'Present' : 'Missing');
    logger.info('  - Selected Profile:', result[BrowserStorageKey.SelectedProfile] || 'None');
    logger.info('  - Is Paused:', result[BrowserStorageKey.IsPaused] || false);

    // –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ñ–∏–ª–µ–π, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
    let activeHeadersCount = 0;
    if (result[BrowserStorageKey.Profiles]) {
      try {
        const profiles = JSON.parse(result[BrowserStorageKey.Profiles] as string);
        logger.info(`  - Profiles count: ${profiles.length}`);
        if (profiles.length > 0) {
          logger.info('  - Profile names:', profiles.map((p: Profile) => p.name || p.id).join(', '));

          // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è badge
          const selectedProfile = profiles.find((p: Profile) => p.id === result[BrowserStorageKey.SelectedProfile]);
          if (selectedProfile) {
            activeHeadersCount = selectedProfile.requestHeaders?.filter((h: RequestHeader) => !h.disabled).length || 0;
            logger.info(`  - Active headers count: ${activeHeadersCount}`);
          }
        }
      } catch (error) {
        logger.warn('  - Failed to parse profiles:', error);
      }
    }

    logger.debug('Background script load storage data:', JSON.stringify(result, null, 2));
    logger.groupEnd();

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º badge –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ storage
    const isPaused = (result[BrowserStorageKey.IsPaused] as boolean) || false;
    await setIconBadge({ isPaused, activeRulesCount: activeHeadersCount });
    logger.info(`üè∑Ô∏è Badge set: paused=${isPaused}, activeRules=${activeHeadersCount}`);
  } catch (error) {
    logger.error('Failed to check storage on background script load:', error);
  }
})();

// Initialize auto-reload only in development mode
if (process.env.NODE_ENV === 'development') {
  enableExtensionReload();
  logger.debug('Extension auto-reload enabled for development mode');
}

const BADGE_COLOR = '#ffffff';

// –î–µ–±–∞—É–Ω—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –ø—Ä–∏ —á–∞—Å—Ç—ã—Ö –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è—Ö –≤–∫–ª–∞–¥–æ–∫
let tabUpdateTimeout: ReturnType<typeof setTimeout> | null = null;
const TAB_UPDATE_DEBOUNCE_MS = 100;

async function notify(message: ServiceWorkerEvent) {
  logger.debug('Received message:', message);

  if (message === ServiceWorkerEvent.Reload) {
    logger.info('üîÑ Reloading headers configuration');

    const result = await browser.storage.local.get([
      BrowserStorageKey.Profiles,
      BrowserStorageKey.SelectedProfile,
      BrowserStorageKey.IsPaused,
    ]);

    logger.info('üì¶ Storage data for reload:', result);
    await setBrowserHeaders(result);
  }
  return undefined;
}

browser.runtime.onStartup.addListener(async function () {
  logger.info('Extension startup triggered');

  const result = await browser.storage.local.get([
    BrowserStorageKey.Profiles,
    BrowserStorageKey.SelectedProfile,
    BrowserStorageKey.IsPaused,
  ]);

  // –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ storage –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
  logger.info('üì¶ Storage contents on startup:');
  logger.info('  - Profiles:', result[BrowserStorageKey.Profiles] ? 'Present' : 'Missing');
  logger.info('  - Selected Profile:', result[BrowserStorageKey.SelectedProfile] || 'None');
  logger.info('  - Is Paused:', result[BrowserStorageKey.IsPaused] || false);
  logger.debug('Startup storage data:', JSON.stringify(result, null, 2));

  // –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ñ–∏–ª–µ–π, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
  if (result[BrowserStorageKey.Profiles]) {
    try {
      const profiles = JSON.parse(result[BrowserStorageKey.Profiles] as string);
      logger.info(`  - Profiles count: ${profiles.length}`);
      if (profiles.length > 0) {
        logger.info('  - Profile names:', profiles.map((p: Profile) => p.name || p.id).join(', '));
      }
    } catch (error) {
      logger.warn('  - Failed to parse profiles:', error);
    }
  }

  logger.debug('Startup storage data:', result);

  if (Object.keys(result).length) {
    logger.info('üöÄ Storage data found, setting browser headers on startup');
    try {
      await setBrowserHeaders(result);
    } catch (error) {
      logger.error('Failed to set browser headers on startup:', error);
    }
  } else {
    logger.info('üì≠ No storage data found on startup - extension will start with default settings');
  }
});

browser.storage.onChanged.addListener(async (changes, areaName) => {
  logger.debug('Storage changes detected in area:', areaName, changes);

  if (areaName === 'local') {
    const relevantChanges = [
      BrowserStorageKey.Profiles,
      BrowserStorageKey.SelectedProfile,
      BrowserStorageKey.IsPaused,
    ].some(key => Object.keys(changes).includes(key));

    if (relevantChanges) {
      logger.info('üìù Relevant storage changes detected, updating headers');
      const result = await browser.storage.local.get([
        BrowserStorageKey.Profiles,
        BrowserStorageKey.SelectedProfile,
        BrowserStorageKey.IsPaused,
      ]);
      logger.debug('Storage changes data:', result);
      try {
        await setBrowserHeaders(result);
      } catch (error) {
        logger.error('Failed to set browser headers on storage change:', error);
      }
    }
  }
});

browser.runtime.onInstalled.addListener(async details => {
  logger.info('Extension installed/updated:', details.reason);

  const result = await browser.storage.local.get([
    BrowserStorageKey.Profiles,
    BrowserStorageKey.SelectedProfile,
    BrowserStorageKey.IsPaused,
  ]);

  // –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ storage –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏
  logger.group('üì¶ Storage contents on install/update:', true);
  logger.info('  - Profiles:', result[BrowserStorageKey.Profiles] ? 'Present' : 'Missing');
  logger.info('  - Selected Profile:', result[BrowserStorageKey.SelectedProfile] || 'None');
  logger.info('  - Is Paused:', result[BrowserStorageKey.IsPaused] || false);
  logger.debug('Install/update storage data:', JSON.stringify(result, null, 2));
  logger.groupEnd();

  // –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Ñ–∏–ª–µ–π, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
  if (result[BrowserStorageKey.Profiles]) {
    try {
      const profiles = JSON.parse(result[BrowserStorageKey.Profiles] as string);
      logger.info(`  - Profiles count: ${profiles.length}`);
      if (profiles.length > 0) {
        logger.info('  - Profile names:', profiles.map((p: Profile) => p.name || p.id).join(', '));
      }
    } catch (error) {
      logger.warn('  - Failed to parse profiles:', error);
    }
  }

  logger.debug('Install/update storage data:', result);

  if (Object.keys(result).length) {
    logger.info('üîß Storage data found, initializing browser headers on install/update');
    try {
      await setBrowserHeaders(result);
    } catch (error) {
      logger.error('Failed to set browser headers on install/update:', error);
    }
  } else {
    logger.info('üì≠ No storage data found on install/update - extension will start with default settings');
  }
});

// –î–µ–±–∞—É–Ω—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –≤–∫–ª–∞–¥–∫–∏
let tabActivationTimeout: ReturnType<typeof setTimeout> | null = null;
const TAB_ACTIVATION_DEBOUNCE_MS = 50;

browser.tabs.onActivated.addListener(async activeInfo => {
  logger.debug('Tab activated:', activeInfo);

  // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–∞—É—Ç –¥–ª—è –¥–µ–±–∞—É–Ω—Å–∞
  if (tabActivationTimeout) {
    clearTimeout(tabActivationTimeout);
  }

  // –î–µ–±–∞—É–Ω—Å –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤ –ø—Ä–∏ –±—ã—Å—Ç—Ä—ã—Ö –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è—Ö –≤–∫–ª–∞–¥–æ–∫
  tabActivationTimeout = setTimeout(async () => {
    const result = await browser.storage.local.get([
      BrowserStorageKey.Profiles,
      BrowserStorageKey.SelectedProfile,
      BrowserStorageKey.IsPaused,
    ]);

    logger.debug('Tab activation storage data:', result);

    if (Object.keys(result).length) {
      logger.info('üì± Tab activated, updating headers');
      try {
        await setBrowserHeaders(result);
      } catch (error) {
        logger.error('Failed to set browser headers on tab activation:', error);
      }
    } else {
      logger.debug('No storage data found on tab activation');
    }
    tabActivationTimeout = null;
  }, TAB_ACTIVATION_DEBOUNCE_MS);
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∫–ª–∞–¥–æ–∫ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
// –û—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–Ω–æ –¥–ª—è Firefox, –≥–¥–µ background script –º–æ–∂–µ—Ç –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—Ç—å—Å—è
// –¢–∞–∫–∂–µ –≤–∞–∂–Ω–æ –ø—Ä–∏ —á–∞—Å—Ç—ã—Ö –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è—Ö –≤–∫–ª–∞–¥–æ–∫ –∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞—Ö —Å—Ç—Ä–∞–Ω–∏—Ü (CTRL + R)
browser.tabs.onUpdated.addListener(async (tabId, changeInfo, tab) => {
  // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ URL
  // –≠—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –ø—Ä–∞–≤–∏–ª–∞ –ø—Ä–∏–º–µ–Ω—è—Ç—Å—è –¥–∞–∂–µ –µ—Å–ª–∏ background script –±—ã–ª –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω
  const isPageLoaded = changeInfo.status === 'complete';
  const isUrlChanged = changeInfo.url !== undefined && changeInfo.url !== null;
  const isValidUrl =
    tab.url &&
    !tab.url.startsWith('chrome-extension://') &&
    !tab.url.startsWith('moz-extension://') &&
    !tab.url.startsWith('about:') &&
    !tab.url.startsWith('chrome://') &&
    !tab.url.startsWith('moz-extension://');

  if ((isPageLoaded || isUrlChanged) && isValidUrl) {
    // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–∞—É—Ç –¥–ª—è –¥–µ–±–∞—É–Ω—Å–∞
    if (tabUpdateTimeout) {
      clearTimeout(tabUpdateTimeout);
    }

    // –î–µ–±–∞—É–Ω—Å –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤ –ø—Ä–∏ –±—ã—Å—Ç—Ä—ã—Ö –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è—Ö –≤–∫–ª–∞–¥–æ–∫
    tabUpdateTimeout = setTimeout(async () => {
      logger.debug('Tab updated (page loaded/URL changed):', {
        tabId,
        url: tab.url,
        status: changeInfo.status,
        urlChanged: isUrlChanged,
      });

      const result = await browser.storage.local.get([
        BrowserStorageKey.Profiles,
        BrowserStorageKey.SelectedProfile,
        BrowserStorageKey.IsPaused,
      ]);

      if (Object.keys(result).length) {
        logger.info('üåê Page loaded/URL changed, ensuring headers are up to date');
        try {
          await setBrowserHeaders(result);
        } catch (error) {
          logger.error('Failed to set browser headers on page load/URL change:', error);
        }
      }
      tabUpdateTimeout = null;
    }, TAB_UPDATE_DEBOUNCE_MS);
  }
});

browserAction.setBadgeBackgroundColor({ color: BADGE_COLOR });

browser.runtime.onMessage.addListener((message: unknown) => {
  notify(message as ServiceWorkerEvent).catch(err => {
    logger.error('Error handling message:', err);
  });
  return undefined;
});
